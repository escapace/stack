#!/usr/bin/env bash
#
# vim: set ft=sh:
#
# @description Run packer configuration test(s)
# @import lang/required
# @import console/info
# @import console/die
# @import console/warn
# @import console/error
# @import console/die
# @import string/upper
# @import string/splitString
# @import lang/exists
# @dependency jq

declare -A PACKER_TEST
declare -A PACKER_TYPE
declare -A PACKER_TEST_MANIFEST
declare -A PACKER_TEST_CODE
declare -A PACKER_TEST_EBS_ARTIFACTS

specVirtualbox () {
    _ exists vagrant || _ die "Cannot find vagrant"

    local code=0
    local directory
    local name="$1"
    local template="${PACKER_TEST[${name}]}"
    local type="${PACKER_TYPE[${name}]}"

    directory="$(dirname "${template}")"

    _ info "Running '${name}' test..."

    (
        cd "${directory}" || return 1

        "${MANAGE_REPOSITORY}/vendor/packer/packer" build \
            -only="${type}" \
            -force \
            "${template}" || return 1
    ) || code=$?

    PACKER_TEST_CODE["${name}"]="${code}"
}

specEBS ()
{
    local code=0
    local directory
    local manifest
    local name="$1"
    local template="${PACKER_TEST[${name}]}"

    _ exists aws || _ die "Cannot find the AWS Command Line Interface (AWS CLI)"

    directory="$(dirname "${template}")"
    manifest="${directory}/$(jq -r '."post-processors" | .[] | select(.type == "manifest") | .output // empty' < "${template}")"

    _ info "Running '${name}' test..."

    (
        cd "${directory}" || return 1

        rm -f "${manifest}" &> /dev/null || true

        if [[ ! -d "$(dirname "${manifest}")" ]]
        then
            mkdir -p "$(dirname "${manifest}")"
        fi

        "${MANAGE_REPOSITORY}/vendor/packer/packer" build \
            -only=amazon-ebs \
            -force \
            "${template}" || return 1

        [[ -f "${manifest}" ]] || return 1
    ) || code=$?

    PACKER_TEST_CODE["${name}"]="${code}"

    if [[ -f "${manifest}" ]]
    then
        PACKER_TEST_MANIFEST["${name}"]="${manifest}"
        PACKER_TEST_EBS_ARTIFACTS["${name}"]="$(jq -r '.builds | .[] | select(.builder_type == "amazon-ebs") | .artifact_id // empty' < "${manifest}")"
    fi
}

routeFile () {
    local file="$1"

    if [ -f "${file}" ] &&
        [[ "$(basename "${file}")" =~ ^[-_a-zA-Z0-9]*\.json$ ]] &&
        [[ ! "$(basename "${file}")" =~ ^[-_a-zA-Z0-9]*manifest\.json$ ]] &&
        [[ "$(basename "${file}")" != "manifest.json" ]]
    then
        local name
        local type
        local types
        name="$(basename "${file}")"
        name="${name%.json}"
        name="$(basename "$(dirname "${file}")")/${name}"
        mapfile -t types <<< "$(jq -r '."builders" | .[] | .type // empty' < "${file}")"

        for type in "${types[@]}"
        do
            name="${name}::${type}"
            PACKER_TEST["${name}"]="${file}"
            PACKER_TYPE["${name}"]="${type}"
        done
    fi
}

main ()
{
    verbose true
    strict true

    [ -f "${MANAGE_REPOSITORY}/vendor/packer/packer" ] || _ die "Download packer first: ./manage download-packer"

    local queue=($@)

    if _ required "${TEST_SUITE}"
    then
        queue=(${TEST_SUITE})
    fi

    if [[ ${#queue[@]} != 0 ]]
    then
        local arg

        for arg in "${queue[@]}"
        do
            local file="${MANAGE_REPOSITORY}/packer/${arg}.json"

            routeFile "${file}"
        done
    else
        while read -d '' -r file
        do
            routeFile "${file}"
        done < <(find "${MANAGE_REPOSITORY}/packer" -not -name "manifest.json" -name "*.json" -maxdepth 3 -type f -print0 2> /dev/null)
    fi

    for name in "${!PACKER_TEST[@]}"
    do
        case "${PACKER_TYPE["${name}"]}" in
            amazon-ebs)
                specEBS "${name}"
                ;;
            virtualbox-iso)
                specVirtualbox "${name}"
                ;;
            *)
                _ warn "Ignoring unsupported builder type '${PACKER_TYPE["${name}"]}'"
        esac
    done
}

onExit ()
{
    local exitCode=0
    local name

    if [[ -z "${STACK_NO_CLEAN}" ]]
    then
        for name in "${!PACKER_TEST_EBS_ARTIFACTS[@]}"
        do
            _ info "Destroying '${name}' managed infrastructure"

            local artifacts=(${PACKER_TEST_EBS_ARTIFACTS[$name]})
            local artifact

            for artifact in "${artifacts[@]}"
            do
                artifact=($(echo "${artifact}" | _ splitString ':'))

                local region="${artifact[0]}"
                local ami="${artifact[1]}"

                {
                    local snapshots=()
                    local volumes=()
                    local localCode=0

                    snapshots=($(
                        AWS_DEFAULT_OUTPUT="json" aws --region "${region}" ec2 describe-images --image-ids "${ami}" \
                            | jq -r '.Images | .[] | .BlockDeviceMappings | .[] | .Ebs.SnapshotId // empty'
                    )) || ((localCode++))

                    if [[ ${#snapshots[@]} != 0 ]]
                    then
                        volumes=($(
                            AWS_DEFAULT_OUTPUT="json" aws --region "${region}" ec2 describe-snapshots --snapshot-ids \
                            "$(_ join "snapshots" ' ')" | jq -r '.Snapshots | .[] | .VolumeId // empty'
                        )) || ((localCode++))
                    fi

                    AWS_DEFAULT_OUTPUT="text" aws --region "${region}" ec2 deregister-image --image-id "${ami}" || ((localCode++))

                    for snapshot in "${snapshots[@]}"
                    do
                        AWS_DEFAULT_OUTPUT="text" aws --region "${region}" ec2 delete-snapshot --snapshot-id "${snapshot}" || ((localCode++))
                    done

                    # NOTE: Packer users pre-built AMIs as the source for building
                    # images.  These source AMIs may include volumes that are not
                    # flagged to be destroyed on termiation of the instance building
                    # the new image. Packer will attempt to clean up all residual
                    # volumes that are not designated by the user to remain after
                    # termination. If you need to preserve those source volumes, you
                    # can overwrite the termination setting by specifying
                    # `delete_on_termination=false` in the `launch_device_mappings`
                    # block for the device.

                    for volume in "${volumes[@]}"
                    do
                        AWS_DEFAULT_OUTPUT="text" aws --region "${region}" ec2 delete-volume --volume-id "${volume}" &> /dev/null || true
                    done

                    return "${localCode}"
                } || ((exitCode++))
            done

            rm -f "${PACKER_TEST_MANIFEST[$name]}" &> /dev/null || true
        done

        for name in "${!PACKER_TEST_CODE[@]}"
        do
            local code="${PACKER_TEST_CODE[$name]}"

            if (( code == 0 ))
            then
                _ info "Ok '${name}'"
            else
                _ error "Error '${name}'"
                ((exitCode++))
            fi
        done

        for name in "${!PACKER_TEST[@]}"
        do
            rm -rf "$(dirname "${PACKER_TEST[$name]}")/packer_cache"
            rm -rf "$(dirname "${PACKER_TEST[$name]}")/builds"
            rm -rf "$(dirname "${PACKER_TEST[$name]}")/output-virtualbox-iso"
            rm -rf "$(dirname "${PACKER_TEST[$name]}")/.vagrant"
        done

        exit "${exitCode}"
    fi
}
